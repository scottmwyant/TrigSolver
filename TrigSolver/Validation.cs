using System;

namespace TrigSolver
{
    class Validation
    {
        public string ErrorMessage;
        private bool error = new bool();
        private DataSet ds;

        public void Test(DataSet ds)
        {
            this.ds = ds;
            Eval(new Spec_ThreeInputs());
            Eval(new Spec_AtLeastOneLength());
            // ... continue to evaluate the data against the specs
            //     until we get to the point where we need to know the profile
            //     Granted, the profile is available this whole time, since the data set was created.

            // Now, check the algorithm, which is a property on the DataSet, generated by the profile.
            if(ds.Algorithm=="SSA")
            {
                Eval(new Spec_SideLengthForSSA());
            }



            //  ***** This would be in the controlller?!?

            //consider something that looks like this
            ISolver solver = SolverFactory(ds.ProfileId); // or DataAdapter?

            solver.Data = ds.Data.Copy;
            // OR
            solver.SetData(ds.Data.Copy);


            Trig.SolveByProfile(solver, ds.ProfileId);

            // then inside the trig class  -->
            solver.calc1 = Trig.AnglesSumToPi_SolveForAngle3(solver.input1, solver.input2);
            return solver.Data // back to the view model

            //*************




            
            // Carry out any secondary validation.  More specs will apply to certain cases.

            // Once the validation is done, return true, otherwise return false.

            // On returning false, the caller should explore the validation response object.


            // Perhaps we should be passing in a spec package that implements IEnumerable?

            
            
        }

        private void Eval(Specification spec)
        {

            if (!this.error)
            {
                if (!spec.IsSatisfiedBy(this.ds))
                {
                    this.error = true;
                    this.ErrorMessage = spec.ErrorMessage;
                }
            }
            
        }





    }

    
}
